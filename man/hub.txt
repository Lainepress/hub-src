git-subtree(1)
==============

NAME
----
hub - manage Haskell hubs


SYNOPSIS
--------
[verse]
hub usage
hub help    [<hub-command>]
hub version
hub default [<g-hub>|-]
hub ls
hub set     [<hub>|-]
hub info    [<hub>]
hub name
hub path    [<hub>]
hub xml     [<hub>]
hub init    [<hub>]   <u-hub'>
hub cp      [<u-hub>] <u-hub'>
hub mv      [<u-hub>] <u-hub'>
hub rm       <u-hub>
hub swap    [<u-hub>] <u-hub'>




DESCRIPTION
-----------

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam egestas mi id lacus tempus adipiscing. 
Pellentesque porta, metus et sollicitudin pellentesque, libero purus ultricies turpis, vitae gravida sapien 
arcu nec orci. Sed euismod augue eget turpis congue iaculis. Nunc gravida ultricies placerat. Pellentesque 
eleifend sapien id ante adipiscing dictum. Fusce ligula lacus, rutrum sed congue id, bibendum et elit. Ut 
id felis vitae nunc ornare sollicitudin. Maecenas porta euismod tincidunt. Fusce aliquet, nisi aliquam 
suscipit venenatis, nisl ante dignissim dui, vitae viverra leo arcu eget magna. Sed condimentum blandit 
odio, id molestie metus tempor id. Ut nisi sapien, adipiscing laoreet lobortis at, porttitor vel tellus. 

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam egestas mi id lacus tempus adipiscing. 
Pellentesque porta, metus et sollicitudin pellentesque, libero purus ultricies turpis, vitae gravida sapien 
arcu nec orci. Sed euismod augue eget turpis congue iaculis. Nunc gravida ultricies placerat. Pellentesque 
eleifend sapien id ante adipiscing dictum. Fusce ligula lacus, rutrum sed congue id, bibendum et elit. Ut 
id felis vitae nunc ornare sollicitudin. Maecenas porta euismod tincidunt. Fusce aliquet, nisi aliquam 
suscipit venenatis, nisl ante dignissim dui, vitae viverra leo arcu eget magna. Sed condimentum blandit 
odio, id molestie metus tempor id. Ut nisi sapien, adipiscing laoreet lobortis at, porttitor vel tellus. 

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam egestas mi id lacus tempus adipiscing. 
Pellentesque porta, metus et sollicitudin pellentesque, libero purus ultricies turpis, vitae gravida sapien 
arcu nec orci. Sed euismod augue eget turpis congue iaculis. Nunc gravida ultricies placerat. Pellentesque 
eleifend sapien id ante adipiscing dictum. Fusce ligula lacus, rutrum sed congue id, bibendum et elit. Ut 
id felis vitae nunc ornare sollicitudin. Maecenas porta euismod tincidunt. Fusce aliquet, nisi aliquam 
suscipit venenatis, nisl ante dignissim dui, vitae viverra leo arcu eget magna. Sed condimentum blandit 
odio, id molestie metus tempor id. Ut nisi sapien, adipiscing laoreet lobortis at, porttitor vel tellus. 



COMMANDS
--------
hub usage::
      Lists the syntax of all the hub commands.

hub help    [<hub-command>]::
      Lists the help for a command or all commands if none specified.

      See "hub usage" for a command-syntax summary.

hub version::
      Lists the version information.

hub default [<g-hub>|-]::
      (Needs to be run as root.)

      If no arguments are given then this command lists the  the default global
      hub for the system (i.e., the default global hub used to set up each
      user's 'home' hub).

      If a global hub <g-hub> is specified then <g-hub> will become the
      default global hub.

      If a '-' is specified then any older default settings are discarded and
      the system default re-established.

hub ls::
      Lists your user hubs and all of the global hubs.

hub set     [<hub>|-]::
      Sets the 'current' hub for a directory and its sub-directories.

      The HUB environment variable can be set to a hub name to override this
      setting.

hub info    [<hub>]::
      Lists the vital stats for the named or current hub.

      (See 'hub set' on how to set the current hub.)

hub name::
      Lists the name of the current hub.

      (See 'hub set' on how to set the current hub.)

hub path    [<hub>]::
      Lists the  path of the XML file defining the named or current hub.

      (See 'hub set' on how to set the current hub.)

hub xml     [<hub>]::
      Lists the contents of the XML file defining the named or current hub.

      (See 'hub set' on how to set the current hub.)

hub init    [<hub>]   <u-hub'>::
      Creates an empty user hub, <u-hub'>. The new hub inherits the global
      hub of <hub> (or the current hub).

      (See 'hub set' on how to set the current hub.)

hub cp      [<u-hub>] <u-hub'>::
      Duplicates the user <u-hub> (or the current hib) in <u-hub'>.

      (See 'hub set' on how to set the current hub.)

hub mv      [<u-hub>] <u-hub'>::
      Renames user hub <u-hub> (or the current hub) to <u-hub'>.

      (See 'hub set' on how to set the current hub.)

hub rm       <u-hub>::
      Deletes user hub <hub>.

hub swap    [<u-hub>] <u-hub'>::
      Swaps the contents of user hub <u-hub> (or the current hub) with
      user hub <u-hub'>.
OPTIONS FOR add, merge, push, pull
----------------------------------
--squash::
	This option is only valid for add, merge, push and pull
	commands.

	Instead of merging the entire history from the subtree
	project, produce only a single commit that contains all
	the differences you want to merge, and then merge that
	new commit into your project.
	
	Using this option helps to reduce log clutter. People
	rarely want to see every change that happened between
	v1.0 and v1.1 of the library they're using, since none of the
	interim versions were ever included in their application.
	
	Using '--squash' also helps avoid problems when the same
	subproject is included multiple times in the same
	project, or is removed and then re-added.  In such a
	case, it doesn't make sense to combine the histories
	anyway, since it's unclear which part of the history
	belongs to which subtree.
	
	Furthermore, with '--squash', you can switch back and
	forth between different versions of a subtree, rather
	than strictly forward.  'git subtree merge --squash'
	always adjusts the subtree to match the exactly
	specified commit, even if getting to that commit would
	require undoing some changes that were added earlier.
	
	Whether or not you use '--squash', changes made in your
	local repository remain intact and can be later split
	and send upstream to the subproject.


OPTIONS FOR split
-----------------
--annotate=<annotation>::
	This option is only valid for the split command.

	When generating synthetic history, add <annotation> as a
	prefix to each commit message.  Since we're creating new
	commits with the same commit message, but possibly
	different content, from the original commits, this can help
	to differentiate them and avoid confusion.
	
	Whenever you split, you need to use the same
	<annotation>, or else you don't have a guarantee that
	the new re-created history will be identical to the old
	one.  That will prevent merging from working correctly. 
	git subtree tries to make it work anyway, particularly
	if you use --rejoin, but it may not always be effective.

-b <branch>::
--branch=<branch>::
	This option is only valid for the split command.

	After generating the synthetic history, create a new
	branch called <branch> that contains the new history. 
	This is suitable for immediate pushing upstream. 
	<branch> must not already exist.

--ignore-joins::
	This option is only valid for the split command.

	If you use '--rejoin', git subtree attempts to optimize
	its history reconstruction to generate only the new
	commits since the last '--rejoin'.  '--ignore-join'
	disables this behaviour, forcing it to regenerate the
	entire history.  In a large project, this can take a
	long time.

--onto=<onto>::
	This option is only valid for the split command.

	If your subtree was originally imported using something
	other than git subtree, its history may not match what
	git subtree is expecting.  In that case, you can specify
	the commit id <onto> that corresponds to the first
	revision of the subproject's history that was imported
	into your project, and git subtree will attempt to build
	its history from there.
	
	If you used 'git subtree add', you should never need
	this option.

--rejoin::
	This option is only valid for the split command.

	After splitting, merge the newly created synthetic
	history back into your main project.  That way, future
	splits can search only the part of history that has
	been added since the most recent --rejoin.
	
	If your split commits end up merged into the upstream
	subproject, and then you want to get the latest upstream
	version, this will allow git's merge algorithm to more
	intelligently avoid conflicts (since it knows these
	synthetic commits are already part of the upstream
	repository).
	
	Unfortunately, using this option results in 'git log'
	showing an extra copy of every new commit that was
	created (the original, and the synthetic one).
	
	If you do all your merges with '--squash', don't use
	'--rejoin' when you split, because you don't want the
	subproject's history to be part of your project anyway.





AUTHOR
------
Written by Chris Dornan <chris@chrisdornan.com>
